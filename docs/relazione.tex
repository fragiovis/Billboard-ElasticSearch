\documentclass[a4paper,11pt]{article}
\usepackage[italian]{babel}
\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage{lmodern}
\usepackage{hyperref}
\usepackage{enumitem}
\usepackage{geometry}
\geometry{margin=1in}

\title{Billboard Lyrics Search\\Relazione Tecnica}
\author{\small Progetto HW2 -- Elasticsearch + Streamlit}
\date{\today}

\begin{document}
\maketitle

\section{Introduzione}
L'obiettivo del progetto è indicizzare testi di brani musicali e fornire un'interfaccia di ricerca semplice ed efficace per:\ \emph{titolo}, \emph{contenuto} (full-text) e \emph{linea esatta} dei testi. L'architettura è basata su Elasticsearch per l'indicizzazione e Streamlit per la UI, con script Python che gestiscono creazione indice, mapping e indicizzazione.

\section{Dataset}
Il dataset consiste in file di testo (\texttt{.txt}) in inglese, collocati in \texttt{data/billboard\_split/}. Ogni file rappresenta il testo di un brano; il nome segue la convenzione \texttt{<Titolo>\_<ID>.txt}, ad esempio \texttt{Without Me\_271.txt}.\par
\smallskip
Operazioni di pre-processing disponibili:
\begin{itemize}[nosep]
  \item \textbf{Rimozione duplicati} basata sul prefisso prima dell'underscore (\texttt{scripts/clean.py}).
  \item \textbf{Normalizzazione base} del contenuto: gli script di indicizzazione leggono i file in UTF-8 e applicano \texttt{strip()} per rimuovere spazi iniziali/finali.
\end{itemize}
Durante l'indicizzazione (\texttt{scripts/fill\_index.py}), il campo \texttt{name} viene ricavato dal nome file rimuovendo l'ID finale (parte dopo l'ultimo underscore).

\section{Architettura e Flusso}
\begin{itemize}[nosep]
  \item \textbf{Elasticsearch} ospita l'indice \texttt{files} e applica il mapping/analyzer definiti in \texttt{config/files.mapping.json}.
  \item \textbf{\texttt{create\_index.py}} crea l'indice \texttt{files} con le impostazioni di analisi e mapping.
  \item \textbf{\texttt{fill\_index.py}} esegue indicizzazione bulk di documenti con campi \texttt{name}, \texttt{content}, \texttt{path}.
  \item \textbf{Streamlit UI} (\texttt{search/search\_streamlit.py}) offre ricerca per \emph{Title}, \emph{Lyrics Content}, \emph{Line Content} e visualizza i lyric preservando gli accapo.
\end{itemize}

\section{Schema dei Dati}
Il mapping definisce esplicitamente:\par
\vspace{0.2em}
\noindent\texttt{name} (\texttt{text}, analyzer \texttt{standard})\;\;\;\;\;
\texttt{content} (\texttt{text}, analyzer \texttt{content\_standard}) con multi-field \texttt{content.by\_line} (\texttt{text}, analyzer \texttt{content\_by\_line}).\par
\smallskip
Il campo \texttt{path} è presente nei documenti indicizzati per tracciabilità ma non è utilizzato nelle ricerche; viene gestito da mapping dinamico di Elasticsearch.

\section{Analyzer: tokenizer e filtri}
La definizione degli analyzer è contenuta nel file \texttt{config/files.mapping.json}:
\begin{itemize}[nosep]
  \item \textbf{Tokenizer personalizzato:} \texttt{newline\_tokenizer} di tipo \texttt{pattern} con espressione regolare \texttt{\\n}. Segmenta il testo usando i ritorni a capo, trattando ogni linea come un'"unità".
  \item \textbf{\texttt{content\_standard}:} analyzer \texttt{custom} con tokenizer \texttt{standard} e filtri \texttt{lowercase}, \texttt{stop}. Mira al full-text search con normalizzazione in minuscolo e rimozione di stopword comuni (inglesi).
  \item \textbf{\texttt{content\_by\_line}:} analyzer \texttt{custom} con tokenizer \texttt{newline\_tokenizer} e filtro \texttt{lowercase}. Consente confronti esatti per linea, ignorando differenze di maiuscole/minuscole.
\end{itemize}
\noindent\textit{Razionale:} per la ricerca sul contenuto è utile un analyzer bag-of-words con stopword removal, mentre per la ricerca di linea si desidera mantenere l'unità semantica della riga del testo. Il tokenizer a newline produce un token per ciascuna riga, abilitando confronti frase-esatti.

\section{Scelte di Ricerca dei Brani}
La UI offre tre modalità, mappate su query Elasticsearch:
\begin{itemize}[topsep=2pt,itemsep=2pt]
  \item \textbf{Title} \rightarrow \texttt{match} su \texttt{name}, con analyzer \texttt{standard}. Ricerca full-text sul titolo, tollerante a ordine/parole.
  \item \textbf{Lyrics Content} \rightarrow \texttt{match} su \texttt{content}, con analyzer \texttt{content\_standard}. Ricerca full-text sui testi, con \texttt{lowercase} e \texttt{stop} per migliorare recall e ridurre rumore.
  \item \textbf{Line Content} \rightarrow \texttt{match\_phrase} su \texttt{content.by\_line}. Con il tokenizer a newline, ogni linea è un token; \texttt{match\_phrase} richiede che la sequenza cercata corrisponda esattamente alla linea (case-insensitive).
\end{itemize}
\paragraph{Implicazioni pratiche.} \emph{Lyrics Content} è adatto a ricerche per parole/parafrasi nel testo (ordine non vincolante), mentre \emph{Line Content} funziona per citazioni esatte di singole righe. Se si preferiscono match parziali di riga, si può valutare \texttt{match} su \texttt{content.by\_line}, ma la semantica di "linea esatta" viene resa meglio con \texttt{match\_phrase}.

\section{Esempi di Query}
\begin{itemize}[nosep]
  \item \textbf{Lyrics Content:} cercando \texttt{attention please} si individueranno brani che contengono entrambi i termini nel testo, anche distanti o in righe diverse.
  \item \textbf{Line Content:} cercando \texttt{May I have your attention, please?} la corrispondenza avverrà solo se esiste una riga identica (al netto del case) nel testo indicizzato.
\end{itemize}

\section{Implementazione UI}
La UI in Streamlit (\texttt{search/search\_streamlit.py}):
\begin{itemize}[nosep]
  \item Offre la scelta della modalità di ricerca via \texttt{st.radio}: Title, Lyrics Content, Line Content.
  \item Costruisce la query Elasticsearch in base alla selezione (\texttt{match}, \texttt{match\_phrase}).
  \item Visualizza i testi preservando gli accapo e gli spazi con CSS inline: \texttt{white-space: pre-wrap} e \texttt{html.escape} per sicurezza.
\end{itemize}

\section{Valutazione e Considerazioni}
\textbf{Vantaggi:}
\begin{itemize}[nosep]
  \item Full-text search robusto grazie a lowercase e stopword removal (\texttt{content\_standard}).
  \item Ricerca per linea affidabile grazie al tokenizer a newline (\texttt{content\_by\_line}).
\end{itemize}
\textbf{Limiti:}
\begin{itemize}[nosep]
  \item \emph{Line Content} richiede corrispondenza precisa di punteggiatura/spazi; varianti non identiche non verranno matchate.
  \item Stopword removal può escludere termini talvolta informativi (es.: "not"). Si può mitigare configurando liste personalizzate o disattivando \texttt{stop}.
\end{itemize}
\textbf{Possibili estensioni:}
\begin{itemize}[nosep]
  \item Stemming/lemmatizzazione (es.: \texttt{snowball}) per aumentare recall su varianti morfologiche.
  \item Evidenziazione (\texttt{highlight}) delle corrispondenze in risposta alla query.
  \item Aggiunta di un campo array \texttt{by\_line} esplicito in sorgente per gestione avanzata (posizioni/versi).
\end{itemize}

\section{Istruzioni Operative}
\begin{enumerate}[nosep]
  \item Avviare Elasticsearch (Docker):\ \texttt{docker run -p 9200:9200 -e discovery.type=single-node docker.elastic.co/elasticsearch/elasticsearch:8.15.0}
  \item Creare l'indice: \texttt{python scripts/create\_index.py}
  \item Indicizzare i documenti: \texttt{python scripts/fill\_index.py}
  \item Avviare la UI: \texttt{streamlit run search/search\_streamlit.py}
\end{enumerate}
\noindent\textbf{Troubleshooting:} se si riceve \texttt{ConnectionRefusedError}, verificare che Elasticsearch risponda a \texttt{http://localhost:9200}. Gli avvisi \texttt{urllib3} su LibreSSL in macOS possono essere ignorati o risolti usando Python di Homebrew.

\section{Conclusioni}
La combinazione di analyzer orientati al full-text e alla granularità per linea consente di coprire efficacemente i principali casi d'uso di ricerca di testi musicali. L'architettura rimane semplice, estendibile e con buone prestazioni per dataset di dimensioni medio-piccole come quello considerato.

\end{document}